#include <stdint.h>                         // Library of Standard Integer Types
#include <stdbool.h>                        // Library of Standard Boolean Types
#include "inc/tm4c123gh6pm.h"               // Definitions for interrupt and register assignments on Tiva C
#include "inc/hw_memmap.h"                  // Macros defining the memory map of the Tiva C Series device
#include "inc/hw_types.h"                   // Defines common types and macros
#include "inc/hw_gpio.h"                    // Defines Macros for GPIO hardware
#include "driverlib/sysctl.h"               // Defines and macros for System Control API of DriverLib
#include "driverlib/interrupt.h"            // Defines and macros for NVIC Controller API of DriverLib
#include "driverlib/gpio.h"                 // Defines and macros for GPIO API of DriverLib
#include "driverlib/timer.h"                // Defines and macros for Timer API of driverLib
#include "driverlib/adc.h"                  // Defines and macros for ADC API of driverLib
#include "driverlib/rom.h"                  // Defines and macros for ROM API of driverLib
#include "driverlib/uart.h"
#include "driverlib/pin_map.h"
#include "utils/uartstdio.h"
#include "driverlib/debug.h"
#include "inc/hw_ints.h"
#include "math.h"
#include "driverlib/i2c.h"
#include "IQmath/IQmathLib.h"
#include "driverlib/rom_map.h"
#include "inc/hw_i2c.h"

#include "i2c.h"


#ifdef DEBUG
void
__error__(char *pcFilename, uint32_t ui32Line)
{
}
#endif


#define MPU_ADDRESS     0x68

#define WHO_AM_I        0x75
#define PWR_MGMT_1      0x6B
#define SMPRT_DIV       0x19
#define CONFIG          0x1A
#define GYRO_CONFIG     0x1B
#define ACC_CONFIG      0x1C
#define INT_PIN_CFG     0x37
#define INT_ENABLE      0x38

#define ACCEL_XOUT_H    0x3B
#define ACCEL_XOUT_L    0x3C
#define ACCEL_YOUT_H    0x3D
#define ACCEL_YOUT_L    0x3E
#define ACCEL_ZOUT_H    0x3F
#define ACCEL_ZOUT_L    0x40

#define GYRO_XOUT_H     0x43
#define GYRO_XOUT_L     0x44
#define GYRO_YOUT_H     0x45
#define GYRO_YOUT_L     0x46
#define GYRO_ZOUT_H     0x47
#define GYRO_ZOUT_L     0x48
#define PI 3.14159265359

int WhoAmI, RegReset;

int accXout_L, accXout_H, accXout;
int accYout_L, accYout_H, accYout;
int accZout_L, accZout_H, accZout;



int gyroXout_L, gyroXout_H, gyroXout;
int gyroYout_L, gyroYout_H, gyroYout;
int gyroZout_L, gyroZout_H, gyroZout;


//float accX,accY;
//float gyroX,gyroY,gyroZ;
float gyroXos[3] = {0,0,0};
float gyroYos[3] = {0,0,0};
float gyroZos;
float accXos[3] = {0,0,0};
float accYos[3]= {0,0,0};

float pitchAcc , rollAcc ;
  float  pitch, roll;
  float p ,r;

void initMPU6050();
void MPUtestConnection();
void readMPU();
//void ComplementaryFilter(_iq16 acc[3],_iq16 gyro[3],float *pitch, float *roll);




int main(void){
       SysCtlClockSet(SYSCTL_SYSDIV_2_5 | SYSCTL_USE_PLL | SYSCTL_XTAL_16MHZ | SYSCTL_OSC_MAIN);

        // Configure peripherals
        SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0);
        SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);
        SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOB);
        SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOE);
        SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);

        // Configure pins for UART
        GPIOPinConfigure(GPIO_PA0_U0RX);
        GPIOPinConfigure(GPIO_PA1_U0TX);
        GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1);
        UARTClockSourceSet(UART0_BASE, UART_CLOCK_PIOSC);
        UARTStdioConfig(0, 115200, 16000000);



        GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_3);

        initI2C();
        initMPU6050();
        MPUtestConnection();




        while(1){
            readMPU();
            SysCtlDelay(1000000);
            UARTprintf("Yaw = %d \n",(int)(gyroZos*57));
            SysCtlDelay(1000000);

        }



}

void initMPU6050()
{



    // wait untill reset is complete


    writeI2C(MPU_ADDRESS, PWR_MGMT_1, (1 << 3) || 0x03 );       // power managment setup, temp sensor OFF, sleep mode OFF ...
    writeI2C(MPU_ADDRESS, SMPRT_DIV, 0x01);                     // sample rate 1kHz
    writeI2C(MPU_ADDRESS, CONFIG, 0x03);                        // disable FSYNC, 41 Hz gyro filtering, 1 kHz sampling      ??????????
    writeI2C(MPU_ADDRESS, GYRO_CONFIG, (3 << 3));               // gyro full scale range --> 2000 deg/s (3 << 3)
    writeI2C(MPU_ADDRESS, ACC_CONFIG, (2 << 3));                // acc full scale range  --> 8g (2 << 3)

    writeI2C(MPU_ADDRESS, INT_PIN_CFG, 0x30);   // Configure INT pin or 0011 0000 ??? 0x30
    writeI2C(MPU_ADDRESS, INT_ENABLE, 0x01);    // Enable interrupt DATA READY bit


    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOE);
    SysCtlDelay(3);
    GPIOPinTypeGPIOInput(GPIO_PORTE_BASE, GPIO_PIN_2); // Set as input


}


void MPUtestConnection()
{

    readI2C(MPU_ADDRESS, WHO_AM_I, &WhoAmI);
    if(WhoAmI == 0x68)
    {
        UARTprintf("Connection successful ! \n");
        GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_3, GPIO_PIN_3);
        SysCtlDelay(1000000);
        GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_3, 0x0);
    }

}

void readMPU()
{



    readI2C(MPU_ADDRESS, ACCEL_XOUT_H, &accXout_H);
    readI2C(MPU_ADDRESS, ACCEL_XOUT_L, &accXout_L);
    readI2C(MPU_ADDRESS, ACCEL_YOUT_H, &accYout_H);
    readI2C(MPU_ADDRESS, ACCEL_YOUT_L, &accYout_L);
    readI2C(MPU_ADDRESS, ACCEL_ZOUT_H, &accZout_H);
    readI2C(MPU_ADDRESS, ACCEL_ZOUT_L, &accZout_L);

    readI2C(MPU_ADDRESS, GYRO_XOUT_H, &gyroXout_H);
    readI2C(MPU_ADDRESS, GYRO_XOUT_L, &gyroXout_L);
    readI2C(MPU_ADDRESS, GYRO_YOUT_H, &gyroYout_H);
    readI2C(MPU_ADDRESS, GYRO_YOUT_L, &gyroYout_L);
    readI2C(MPU_ADDRESS, GYRO_ZOUT_H, &gyroZout_H);
    readI2C(MPU_ADDRESS, GYRO_ZOUT_L, &gyroZout_L);

    accXout = ((accXout_H << 8) | accXout_L);
    accYout = ((accYout_H << 8) | accYout_L);
    accZout = ((accZout_H << 8) | accZout_L);

    gyroXout = ((gyroXout_H << 8) | gyroXout_L);
    gyroYout = ((gyroYout_H << 8) | gyroYout_L);
    gyroZout = ((gyroZout_H << 8) | gyroZout_L);


    if(accXout&0x8000) accXout|=0xFFFF0000;
    if(accYout&0x8000) accYout|=0xFFFF0000;
    if(accZout&0x8000) accZout|=0xFFFF0000;

    if(gyroXout&0x8000) gyroXout|=0xFFFF0000;
    if(gyroYout&0x8000) gyroYout|=0xFFFF0000;
    if(gyroZout&0x8000) gyroZout|=0xFFFF0000;




    accXos[0] = -atan2(accXout, accZout);
    accYos[0] = -atan2(accYout, accZout);


    gyroXos[0] = (float)gyroYout * 0.00106422515365507901031932363932f;     // pi/(180*16.4)
        gyroYos[0] = -(float)gyroXout * 0.00106422515365507901031932363932f;
        gyroZos = (float)gyroZout * 0.06097478f; //degree / second




   pitch =   gyroXos[0];
   // UARTprintf(" P =%f \n",pitch);
    roll =  gyroYos[0];
    //UARTprintf(" R =%f \n",roll);

    pitchAcc = accXos[0];
    rollAcc = accYos[0];


    int forceMagnitude = abs(accXout) + abs(accYout);
    UARTprintf(" %d \n",forceMagnitude);
    if(forceMagnitude > 8129 && forceMagnitude < 32768){

        //pitchAcc = -atan2((float)accXout,(float)accYout) * 180 / PI;

        pitch =pitch * 0.98 + pitchAcc * 0.02;
       // UARTprintf("P= %d \n",(int)pitch);

        //rollAcc = -atan2((float)accXout,(float)accYout) * 180 / PI;

        pitch =roll * 0.98 + rollAcc * 0.02;




        p = pitch;
          r = roll;




    }




}
/*void ComplementaryFilter(_iq16 acc[2],_iq16 gyro[3],float *pitch, float *roll){
    acc[0] = accd[0];
    acc[1] =  accd[1];

    gyro[0] =  gyrod[0];
    gyro[1] =  gyrod[1];
    gyro[2] =  gyrod[2];

    float pitchAcc, rollAcc;

    *pitch +=((float)gyro[0] / GYRO_CONFIG );
    *roll -=((float)gyro[1] / GYRO_CONFIG );

    int forceMagnitude = abs(acc[0] + abs(acc[1]) );
    if(forceMagnitude > 8129 && forceMagnitude < 32768){

        pitchAcc = atan2f((float)acc[0],(float)acc[1]) * 180 / PI;
        *pitch = *pitch * 0.98 + pitchAcc * 0.02;

        rollAcc = atan2f((float)acc[0],(float)acc[1]) * 180 / PI;
        *roll = *roll * 0.98 + rollAcc * 0.02;


    }

    UARTprint("Pitch = %f\n",*pitch);


}*/


void initI2C(void)
{

    SysCtlPeripheralEnable(SYSCTL_PERIPH_I2C0);
    SysCtlDelay(3);

    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOB);
    SysCtlDelay(3);

    GPIOPinConfigure(GPIO_PB2_I2C0SCL);
    GPIOPinConfigure(GPIO_PB3_I2C0SDA);

    GPIOPinTypeI2CSCL(GPIO_PORTB_BASE, GPIO_PIN_2);
    GPIOPinTypeI2C(GPIO_PORTB_BASE, GPIO_PIN_3);

    I2CMasterInitExpClk(I2C0_BASE, SysCtlClockGet(), true);

}

void readI2C(uint8_t slave_addr, uint8_t reg, int *data)
{
    I2CMasterSlaveAddrSet(I2C0_BASE, slave_addr, false);
    I2CMasterDataPut(I2C0_BASE, reg);
    I2CMasterControl(I2C0_BASE, I2C_MASTER_CMD_BURST_SEND_START);
    while(I2CMasterBusy(I2C0_BASE));
    I2CMasterSlaveAddrSet(I2C0_BASE, slave_addr, true);
    I2CMasterControl(I2C0_BASE, I2C_MASTER_CMD_SINGLE_RECEIVE);
    while(I2CMasterBusy(I2C0_BASE));
    *data = I2CMasterDataGet(I2C0_BASE);
}


// Sends 1 byte over i2c
void writeI2C(uint8_t slave_addr, uint8_t reg, uint8_t data)
{
    I2CMasterSlaveAddrSet(I2C0_BASE, slave_addr, false);
    I2CMasterDataPut(I2C0_BASE, reg);
    I2CMasterControl(I2C0_BASE, I2C_MASTER_CMD_BURST_SEND_START);
    while(I2CMasterBusy(I2C0_BASE));
    I2CMasterDataPut(I2C0_BASE, data);
    I2CMasterControl(I2C0_BASE, I2C_MASTER_CMD_BURST_SEND_FINISH);
    while(I2CMasterBusy(I2C0_BASE));
}

